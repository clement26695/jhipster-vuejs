import { shallowMount, createLocalVue, Wrapper } from '@vue/test-utils';
import axios from 'axios';
import sinon from 'sinon';

import * as config from '@/shared/config/config';
import Settings from '@/account/settings/settings.vue';
import SettingsClass from '@/account/settings/settings.component';
import { EMAIL_ALREADY_USED_TYPE } from '@/constants';

const localVue = createLocalVue();

config.initVueApp(localVue);
<%_ if (enableTranslation) { _%>
const i18n = config.initI18N(localVue);
<%_ } _%>
const store = config.initVueXStore(localVue);

describe('Settings Component', () => {
  let wrapper: Wrapper<SettingsClass>;
  let settings: SettingsClass;
  const account = {
    firstName: 'John',
    lastName: 'Doe',
    email: 'john.doe@jhipster.org'
  };

  beforeEach(() => {
    // axios.get = sinon.stub().returns(Promise.resolve({});

    store.commit('authenticated', account);
    wrapper = shallowMount<SettingsClass>(Settings,
      {
        store,
        <%_ if (enableTranslation) { _%>
        i18n,
        <%_ } _%>
        localVue
      });
    settings = wrapper.vm;
  });

  it('should be a Vue instance', () => {
    expect(wrapper.isVueInstance()).toBeTruthy();
  });

  it('should send the current identity upon save', async () => {
    // GIVEN
    axios.post = sinon.stub().returns(Promise.resolve({}));

    // WHEN
    settings.save();
    await settings.$nextTick();

    // THEN
    expect(axios.post).toHaveBeenCalledWith('api/account', account);
  });

  it('should notify of success upon successful save', async () => {
    // GIVEN
    axios.get = sinon.stub().returns(Promise.resolve(account));

    // WHEN
    settings.save();
    await settings.$nextTick();

    // THEN
    expect(settings.error).toBeNull();
    expect(settings.success).toBe('OK');
  });

  it('should notify of error upon failed save', async () => {
    // GIVEN
    const error = { response: { status: 417 } };
    axios.get = sinon.stub().returns(Promise.reject(error));

    // WHEN
    settings.save();
    await settings.$nextTick();

    // THEN
    expect(settings.error).toEqual('ERROR');
    expect(settings.errorEmailExists).toBeNull();
    expect(settings.success).toBeNull();
  });

  it('should notify of error upon error 400', async () => {
    // GIVEN
    const error = { response: { status: 400, data: {} } };
    axios.get = sinon.stub().returns(Promise.reject(error));

    // WHEN
    settings.save();
    await settings.$nextTick();

    // THEN
    expect(settings.error).toEqual('ERROR');
    expect(settings.errorEmailExists).toBeNull();
    expect(settings.success).toBeNull();
  });

  it('should notify of error upon email already used', async () => {
    // GIVEN
    const error = { response: { status: 400, data: { type: EMAIL_ALREADY_USED_TYPE } } };
    axios.get = sinon.stub().returns(Promise.reject(error));

    // WHEN
    settings.save();
    await settings.$nextTick();

    // THEN
    expect(settings.errorEmailExists).toEqual('ERROR');
    expect(settings.error).toBeNull();
    expect(settings.success).toBeNull();
  });
});
